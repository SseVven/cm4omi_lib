```mermaid
flowchart LR
A>拟合数据点]
B>拟合类型] --> C[残差方程]
D[拟合函数]
A --> D
C --> D --> O>拟合参数]
```

## 接口使用说明

需要使用到的大致分为3类接口：

1. 模型类接口（定义不同的模型，创建特的参数的模型）/SpaceMath/Geometry.h
2. 坐标定义类（用于定义测量点等数学信息）/Model/Model.h
3. 拟合接口（接收模型和拟合点信息，自动拟合）/Reconstruction/reconstructor.h

### 使用案例

```cpp
#include <iostream>
#include "../SpaceMath/Geometry.h"
#include "../Model/Cone.h"
#include "../Reconstruction/reconstructor.h"

int main() {
	/*************************sphere***************************/
    Sphere sphere_standard(Point(20, 30, 40), 20);
	Sphere sphere_actual(Point(19.99807462, 30.00129321, 41.0002376), 21.000190102613473);
	// 拟合
	// 输入拟合类型，拟合的数据点，和初始的预测参数
	std::vector<std::vector<double>> data = { 
		{13.90945534, 40.5491328 , 61.09826561},
		{13.90974565, 19.45137004, 61.09725992},
		{32.18005038, 30.        , 61.09646609},
		{9.61367915 ,47.98963542 ,51.99309028},
		{9.61453703 ,12.01185047 ,51.99209968},
		{40.76957166, 30.        , 51.99131779},
		{8.25951173 ,50.33512219 ,40.},
		{8.26063173 , 9.6668177  ,40.},
		{43.4769685 , 30.        , 40.}};
	reconstructor rc(&sphere_standard, data);
	std::vector<double> thetas = rc.fit();
	for (double x : thetas)
		std::cout << x << " ";
   	/*************************sphere***************************/
	/*************************cone***************************/
	double s_height = 40;
	Vec s_vec = Vec(0, 0, 1);
	Point s_bp = Point(20, 40, 30); // 标称的圆锥底面中心
	Point s_tp = s_bp + s_vec * s_height; // 标称的圆锥锥点
	Cone cone_standard(s_tp, s_vec, 0.927295218001612);
	// 实际cone参数不参与运算，只给我们一个拟合后的对比参看
	double a_height = 40;
	Vec a_vec = Vec(0.010156064710623948, -0.004186331321546835, 0.9999396626695332);
	Point a_bp = Point(20.000319169987822, 40.00045980044738, 29.99917131787309);
	Point a_tp = a_bp + a_vec * a_height;
	Cone cone_actual(a_tp, a_vec, 0.929294217835695);
	// 拟合点信息
	std::vector<std::vector<double>> data = {
		{28.08532736152396, 54.00419778598631, 43.33333333333333},
		{11.940997474310906, 53.958601832819426, 43.33333333333333},
		{3.8898525637580974, 40.0, 43.33333333333333},
		{11.922829647701983, 26.00993056843084, 43.33333333333333},
		{28.104301293563697, 25.962938399701507, 43.33333333333333},
		{24.754067652978776, 48.23428671757896, 56.666666666666664},
		{15.356232641332355, 48.04324100374229, 56.666666666666664},
		{10.743996175204051, 40.0, 56.666666666666664},
		{15.278321582379286, 31.821813083679515, 56.666666666666664},
		{24.834274728878956, 31.62679055183539, 56.666666666666664},
	};
    // 构建拟合类，得传入模型的指针，用于自动判断模型的类型，多态
	reconstructor rc(&cone_standard, data);
    // 调用拟合函数
	std::vector<double> thetas = rc.fit();
    // 打印拟合后的参数对比
	for (double x : thetas)
		std::cout << x << " ";
	system("pause");
	return 0;
	/*************************cone***************************/
}
```

## VS信息

### VS版本

Microsoft Visual Studio Community 2022 (64 位) - Current
版本 17.13.4

### VS项目配置

查看项目的vcxproj文件

## 项目编译指南

​	每个模块分别编译生成对应的 dll和lib文件，将所需使用的库添加进vs项目设置的链接器的引用库信息中，还用导入对应的头文件，即可使用对应的dll库。

![image-20250331180935061](D:\Projects\cm4omi_lib\assets\image-20250331180935061.png)
